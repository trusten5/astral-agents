# ==============================================================================
# run_items.py â€” Agent run item models and type aliases                       
# ============================================================================== 
# Purpose: Define dataclasses representing items generated during agent runs, 
#          including messages, tool calls, and reasoning items.                 
# Sections: Imports, Type Aliases, Dataclasses, Public Exports                 
# ============================================================================== 

# ============================================================================== 
# Imports                                                                        
# ============================================================================== 

# Standard Library --------------------------------------------------------------
import abc
import copy
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeVar, Union

# Third-Party -------------------------------------------------------------------
from pydantic import BaseModel
from typing_extensions import TypeAlias

# OpenAI SDK - Replace w/ Astral --------------------------------------------------------------------
from openai.types.responses import (
    Response,
    ResponseComputerToolCall,
    ResponseFileSearchToolCall,
    ResponseFunctionToolCall,
    ResponseFunctionWebSearch,
    ResponseInputItemParam,
    ResponseOutputItem,
    ResponseOutputMessage,
    ResponseOutputRefusal,
    ResponseOutputText,
    ResponseStreamEvent,
)
from openai.types.responses.response_input_item_param import (
    ComputerCallOutput,
    FunctionCallOutput,
)
from openai.types.responses.response_reasoning_item import ResponseReasoningItem

# Internal ----------------------------------------------------------------------
from .exceptions import AgentsException, ModelBehaviorError

if TYPE_CHECKING:
    from .agent import Agent


# ============================================================================== 
# Type Aliases                                                                
# ============================================================================== 

TResponse: TypeAlias = Response
"""Alias for OpenAI SDK Response type."""

TResponseInputItem: TypeAlias = ResponseInputItemParam
"""Alias for OpenAI SDK ResponseInputItemParam type."""

TResponseOutputItem: TypeAlias = ResponseOutputItem
"""Alias for OpenAI SDK ResponseOutputItem type."""

TResponseStreamEvent: TypeAlias = ResponseStreamEvent
"""Alias for OpenAI SDK ResponseStreamEvent type."""

T = TypeVar("T", bound=Union[TResponseOutputItem, TResponseInputItem])

ToolCallItemTypes: TypeAlias = Union[
    ResponseFunctionToolCall,
    ResponseComputerToolCall,
    ResponseFileSearchToolCall,
    ResponseFunctionWebSearch,
]
"""Union type representing all tool call item variants."""

RunItem: TypeAlias = Union[
    "MessageOutputItem",
    "HandoffCallItem",
    "HandoffOutputItem",
    "ToolCallItem",
    "ToolCallOutputItem",
    "ReasoningItem",
]
"""Union type representing all possible run items."""


# ============================================================================== 
# Dataclasses                                                                    
# ============================================================================== 


@dataclass
class RunItemBase(Generic[T], abc.ABC):
    """Base class for items generated by an agent run."""

    agent: "Agent[Any]"
    """Agent that generated this item."""

    raw_item: T
    """Raw response item from the run."""

    def to_input_item(self) -> TResponseInputItem:
        """
        Convert the raw item to an input item suitable for model consumption.

        Returns:
            Input item dict or model dump excluding unset fields.

        Raises:
            AgentsException: If raw_item type is unexpected.
        """
        if isinstance(self.raw_item, dict):
            # Input items are dicts; safe to ignore type here.
            return self.raw_item  # type: ignore
        if isinstance(self.raw_item, BaseModel):
            # Output items are Pydantic models convertible to input dicts.
            return self.raw_item.model_dump(exclude_unset=True)  # type: ignore
        raise AgentsException(f"Unexpected raw item type: {type(self.raw_item)}")


@dataclass
class MessageOutputItem(RunItemBase[ResponseOutputMessage]):
    """Represents a message output from the LLM."""

    raw_item: ResponseOutputMessage
    type: Literal["message_output_item"] = "message_output_item"


@dataclass
class HandoffCallItem(RunItemBase[ResponseFunctionToolCall]):
    """Represents a tool call for agent handoff."""

    raw_item: ResponseFunctionToolCall
    type: Literal["handoff_call_item"] = "handoff_call_item"


@dataclass
class HandoffOutputItem(RunItemBase[TResponseInputItem]):
    """Represents the output of an agent handoff."""

    raw_item: TResponseInputItem
    source_agent: "Agent[Any]"
    target_agent: "Agent[Any]"
    type: Literal["handoff_output_item"] = "handoff_output_item"


@dataclass
class ToolCallItem(RunItemBase[ToolCallItemTypes]):
    """Represents a tool call such as function or computer action."""

    raw_item: ToolCallItemTypes
    type: Literal["tool_call_item"] = "tool_call_item"


@dataclass
class ToolCallOutputItem(RunItemBase[Union[FunctionCallOutput, ComputerCallOutput]]):
    """Represents the output of a tool call."""

    raw_item: Union[FunctionCallOutput, ComputerCallOutput]
    output: Any
    type: Literal["tool_call_output_item"] = "tool_call_output_item"


@dataclass
class ReasoningItem(RunItemBase[ResponseReasoningItem]):
    """Represents a reasoning step in the agent's run."""

    raw_item: ResponseReasoningItem
    type: Literal["reasoning_item"] = "reasoning_item"


@dataclass
class ModelResponse:
    """Encapsulates the full response from a model run."""

    output: list[TResponseOutputItem]
    usage: Usage
    response_id: str | None

    def to_input_items(self) -> list[TResponseInputItem]:
        """
        Convert model outputs into input items suitable for subsequent calls.

        Returns:
            List of input items derived from outputs.
        """
        return [item.model_dump(exclude_unset=True) for item in self.output]  # type: ignore


# ============================================================================== 
# Public exports                                                                 
# ============================================================================== 
__all__ = [
    "RunItemBase",
    "MessageOutputItem",
    "HandoffCallItem",
    "HandoffOutputItem",
    "ToolCallItem",
    "ToolCallOutputItem",
    "ReasoningItem",
    "ModelResponse",
    "TResponse",
    "TResponseInputItem",
    "TResponseOutputItem",
    "TResponseStreamEvent",
    "T",
    "ToolCallItemTypes",
    "RunItem",
]


# ============================================================================== 
# To-Do                                                                       
# ============================================================================== 

# class ItemHelpers:
#     @classmethod
#     def extract_last_content(cls, message: TResponseOutputItem) -> str:
#         """Extracts the last text content or refusal from a message."""
#         if not isinstance(message, ResponseOutputMessage):
#             return ""

#         last_content = message.content[-1]
#         if isinstance(last_content, ResponseOutputText):
#             return last_content.text
#         elif isinstance(last_content, ResponseOutputRefusal):
#             return last_content.refusal
#         else:
#             raise ModelBehaviorError(f"Unexpected content type: {type(last_content)}")

#     @classmethod
#     def extract_last_text(cls, message: TResponseOutputItem) -> str | None:
#         """Extracts the last text content from a message, if any. Ignores refusals."""
#         if isinstance(message, ResponseOutputMessage):
#             last_content = message.content[-1]
#             if isinstance(last_content, ResponseOutputText):
#                 return last_content.text

#         return None

#     @classmethod
#     def input_to_new_input_list(
#         cls, input: str | list[TResponseInputItem]
#     ) -> list[TResponseInputItem]:
#         """Converts a string or list of input items into a list of input items."""
#         if isinstance(input, str):
#             return [
#                 {
#                     "content": input,
#                     "role": "user",
#                 }
#             ]
#         return copy.deepcopy(input)

#     @classmethod
#     def text_message_outputs(cls, items: list[RunItem]) -> str:
#         """Concatenates all the text content from a list of message output items."""
#         text = ""
#         for item in items:
#             if isinstance(item, MessageOutputItem):
#                 text += cls.text_message_output(item)
#         return text

#     @classmethod
#     def text_message_output(cls, message: MessageOutputItem) -> str:
#         """Extracts all the text content from a single message output item."""
#         text = ""
#         for item in message.raw_item.content:
#             if isinstance(item, ResponseOutputText):
#                 text += item.text
#         return text

#     @classmethod
#     def tool_call_output_item(
#         cls, tool_call: ResponseFunctionToolCall, output: str
#     ) -> FunctionCallOutput:
#         """Creates a tool call output item from a tool call and its output."""
#         return {
#             "call_id": tool_call.call_id,
#             "output": output,
#             "type": "function_call_output",
#         }